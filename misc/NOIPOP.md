# MPC without Ipopt/CppAD

This project originally implemented `navcon::pred::MPCFollower` using
Ipopt + CppAD via `CppAD::ipopt::solve`. That version required:

- Eigen3
- CppAD (automatic differentiation)
- Ipopt (nonlinear constrained optimizer)

The new implementation removes the Ipopt/CppAD dependency for the core
`MPCFollower` while keeping the public interface and configuration
(`MPCConfig`) as stable as possible.

## Original MPC (Ipopt-based)

Characteristics:

- **Formulation**
  - Multiple-shooting nonlinear program.
  - Decision variables included *both* states and controls over the
    horizon:
    - States: `x, y, yaw, v, cte, epsi` for each step.
    - Controls: `steering, acceleration` for each step.
  - Dynamics, initial conditions, and steering-rate limits were enforced
    as *equality/inequality constraints*.

- **Cost**
  - Quadratic terms on:
    - Cross-track error (`cte`).
    - Heading error (`epsi`).
    - Velocity tracking error (`v - v_ref`).
    - Control effort (`steering`, `acceleration`).
    - Control rate (`Δsteering`, `Δacceleration`).

- **Solver**
  - CppAD provided automatic differentiation for cost and constraints.
  - Ipopt solved the resulting constrained NLP using an interior-point
    method with:
    - Robust line search / globalization.
    - Second-order information (Hessian).
    - Sparse linear algebra.
  - Produced smooth, high-quality solutions but required heavy external
    dependencies and more complex build configuration.

## New MPC (MPCOptimizer – Eigen-only)

Characteristics:

- **Formulation**
  - Single-shooting problem over *controls only*:
    - Decision vector `u = [steering_0, accel_0, ..., steering_{N-1}, accel_{N-1}]`.
  - States are generated by forward-simulating the kinematic bicycle
    model from the current state.
  - Physical limits (steering, acceleration, velocity) are enforced
    via clamping instead of explicit inequality constraints.
  - Steering-rate limits are encoded as **soft penalties** in the cost,
    not hard constraints.

- **Cost**
  - Same structure as the original implementation:
    - Path tracking (`cte`, `epsi`, velocity error).
    - Control effort (steering, acceleration).
    - Control smoothness (`Δsteering`, `Δacceleration`).
  - Implemented directly in C++ using scalar math (no AD types).

- **Solver**
  - Custom `MPCOptimizer` class (in `src/navcon/pred/mpc.cpp`):
    - Uses Eigen for small dense linear algebra.
    - Approximates the gradient via finite differences.
    - Uses a **BFGS quasi-Newton** update for an approximate inverse
      Hessian.
    - Applies **Armijo backtracking line search** to choose a step size.
    - Projects controls back into bounds and applies a 5-point
      Savitzky–Golay-style smoothing on the steering and acceleration
      sequences to reduce high-frequency wiggles.
  - No external nonlinear solver or AD library is needed.

## Trade-offs

- **Pros of the new implementation**
  - No Ipopt/CppAD dependency for `MPCFollower`.
  - Simpler build and portability: only Eigen3 is required.
  - Optimization logic is local to `src/navcon/pred/mpc.cpp`, making it
    easier to experiment with different optimization strategies.

- **Cons / Differences vs. Ipopt**
  - Fewer guarantees:
    - Only handles box constraints explicitly.
    - Steering-rate and other limits are handled via soft penalties
      instead of strict constraints.
    - Convergence quality depends more on tuning (step sizes, horizon,
      weights).
  - Uses finite-difference gradients (slower and less precise than AD),
    which may limit how aggressive the horizon length or sample rate
    can be.
  - Not as robust as Ipopt on hard problems, but sufficient for
    typical path-tracking tasks.

## Future directions

Ideas if we revisit a more advanced solver in the future:

- Keep `MPCFollower`’s public API and cost structure as-is, but:
  - Swap `MPCOptimizer` for:
    - A better quasi-Newton or trust-region method.
    - A small QP-based approximation if we linearize the model.
    - A pluggable interface so external solvers (Ipopt, OSQP, etc.)
      can be used when available.
- Parameterize controls as steering **rate** + acceleration (like the
  MPPI reference implementation in `xtra/mppi`) for even smoother
  control profiles.
- Optionally reintroduce Ipopt/CppAD behind a separate build flag for
  users who want the full original behavior and are willing to manage
  the dependencies.

